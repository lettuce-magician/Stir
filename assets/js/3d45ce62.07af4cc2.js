"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[119],{23553:e=>{e.exports=JSON.parse('{"functions":[{"name":"AttributeBind","desc":"Does the exact same thing as `Bind`, however it\\nuses an attribute instead of a property.\\n\\n```lua\\nlocal Mana = AttributeBind(Humanoid, \\"Mana\\")\\nlocal MaxMana = AttributeBind(Humanoid, \\"MaxMana\\")\\n```","params":[{"name":"Inst","desc":"","lua_type":"Instance"},{"name":"Attr","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Value"}],"function_type":"static","source":{"line":20,"path":"src/AttributeBind.lua"}},{"name":"Bind","desc":"Binds a value to a property, and whenever the property\\nupdates, it also updates. Yes, `Out` exists however this\\nis useful when you\'re just getting a property and you don\'t\\nwant to use Hydration for it, like getting Humanoid\'s Health.\\n\\n```lua\\nlocal Health = Bind(Humanoid, \\"Health\\")\\nlocal MaxHealth = Bind(Humanoid, \\"MaxHealth\\")\\n```","params":[{"name":"Inst","desc":"","lua_type":"Instance"},{"name":"Prop","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Value"}],"function_type":"static","source":{"line":24,"path":"src/Bind.lua"}},{"name":"Child","desc":"This function is very useful when in pairs with `Hydrate`.\\nWhat it simply does is that it hydrates the child of the\\ncurrent instance by name. If the child does not exist it\\nwill throw an error.\\n\\n```lua\\nlocal Frame = New \\"Frame\\" {\\n\\t[Children] = {\\n\\t\\tNew \\"UIStroke\\" {}\\n\\t}\\n}\\n\\nprint(Frame.UIStroke.Color) -- 0, 0, 0\\n\\nHydrate (Frame) {\\n\\t[Child \\"UIStroke\\"] = {\\n\\t\\tColor = Color3.new(1,1,1)\\n\\t}\\n}\\n\\nprint(Frame.UIStroke.Color) -- 1, 1, 1\\n```","params":[{"name":"childName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"SpecialKey"}],"function_type":"static","source":{"line":38,"path":"src/Child.lua"}},{"name":"Clone","desc":"A shorthand for cloning instances and hydrating them in the spot.\\n\\n```lua\\nlocal ToDuplicate = -- insert here some code that creates an instance --\\nlocal AnDuplicate = Clone (ToDuplicate) {\\n    Parent = workspace\\n}\\n\\nprint(ToDuplicate == AnDuplicate) --\x3e false\\n```","params":[{"name":"Inst","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"(Props:PubTypes.PropertyTable) ->(typeof(Inst:Clone()))\\r\\n"}],"function_type":"static","source":{"line":21,"path":"src/Clone.lua"}},{"name":"Component","desc":"Creates a component, which is essentially a piece of a UI Element\\ninside a function that can be built by calling it with the specified\\narguments, however, this makes it easier to apply validation.\\n\\n`Allowed` params indicates the properties that are inside that component,\\nthe structure of the table should be the property name as key and their\\ntype in the form of a string as value. If the table includes a property\\nof the instance that the component returns, it will automatically hydrate\\nit (*this does not apply to events*), to allow the parameter to get any type,\\nset it to \\"any\\".\\n\\n`Callback` is the callback that returns the component itself, it receives\\nall the allowed properties, incluinding instance properties.\\n```lua\\nlocal Button = Component({Text=\\"string\\", Activated=\\"function\\"}, function(Props)\\n    return New \\"TextButton\\" {\\n        [OnEvent \\"Activated\\"] = Props.Activated\\n    }\\nend)\\n\\nlocal Test = Button {\\n    Text = \\"Hello World!\\",\\n    Activated = function()\\n        print(\\"Clicked!\\")\\n    end\\n}\\n\\nprint(Test.Text) --\x3e Hello World!\\n```\\n:::info\\nJust reinforcing: this is almost no different from simply creating a function\\nand returning an instance created by Fusion, this just adds\\ntype validation and auto-hydration.\\n:::","params":[{"name":"Allowed","desc":"","lua_type":"{[string]: TypeNames}"},{"name":"Callback","desc":"","lua_type":"(Props: PropertyTable) -> (T)}"}],"returns":[{"desc":"","lua_type":"(Props: PropertyTable)->(T)"}],"function_type":"static","source":{"line":53,"path":"src/Component.lua"}},{"name":"Each","desc":"Each is used for looping through a key/value pair table and adding children or adding specific\\nproperties. If the passed value is a state, then everytime the state updates, it will react\\naccordingly.\\n\\n```lua\\nNew \\"Frame\\" {\\n\\tNew \\"UIGridLayout\\" {}\\n\\t[Each(Settings)] = function(Key,Value)\\n\\t\\treturn New \\"TextLabel\\" {\\n\\t\\t\\tText = Key..\\": \\"..Value\\n\\t\\t}\\n\\tend\\n}\\n```\\n\\n:::warning\\n`Each` uses `pairs` for looping through the table, meaning list elements will not\\nappear sequencially. In that case, use `Iter` instead for lists and sequencial\\nvalues.\\n:::","params":[{"name":"dict","desc":"","lua_type":"PubTypes.CanBeState<{[string]:any}>"}],"returns":[{"desc":"","lua_type":"PubTypes.SpecialKey\\r\\n"}],"function_type":"static","source":{"line":32,"path":"src/Each.lua"}},{"name":"ElseIf","desc":"This function opens another clause inside an `If` statement.\\nHowever unlike the `If` statement, it is not reactive, and\\nonly updates when the value inside `If` does. However this\\nstill checks if the passed condition is true before hydrating\\nit.\\n\\n```lua\\nlocal State = Value(false)\\nlocal CheckBox = New \\"TextButton\\" {\\n    [If(State)] = { -- Updates whenver the value `State` changes.\\n        Text = \\"Activated\\",\\n        [ElseIf(State:get() == false)] = { -- if the state value is false\\n            Text = \\"Deactivated\\"\\n        },\\n        [Else] = { -- If the state value is any other value\\n            Text = \\"What the....\\"\\n        }\\n    },\\n\\n    [OnEvent \\"Activated\\"] = function()\\n        if math.random(1,20) < 5 then\\n            State:set(nil)\\n        else\\n            State:set(not State:get())\\n        end\\n    end\\n}\\n```","params":[{"name":"conditional","desc":"","lua_type":"PubTypes.CanBeState<boolean>"}],"returns":[{"desc":"","lua_type":"SpecialKey"}],"function_type":"static","source":{"line":42,"path":"src/ElseIf.lua"}},{"name":"Form","desc":"Creates a Form object, which is used for creating stuff like login pages\\nand quizes.\\n\\nThe first argument is a dictionary, with Form Field names as keys, and\\ntheir validation function as values. The validator functions gets two parameters:\\nThe value that was submitted and a function that decides whenver the field will\\nbe allowed to post. The validator function needs to return a boolean which indicates\\nif there are errors on the validated value, and an error message if there is an error.\\n\\n```lua\\nlocal LoginPage = Form {\\n    Password = function(CurrentValue:string, CanPost:(boolean, string)->(boolean, string))\\n        return CanPost(#CurrentValue >= 8, \\"Password must be atleast 8 characters long!\\")\\n    end\\n}\\n\\nLoginPage:onSubmit(function(result)\\n    print(result)\\nend)\\n\\nLoginPage:onPost(function()\\n    print(\\"Password posted successfully!\\")\\nend)\\n\\nLoginPage:onError(function(errors)\\n    print(errors)\\nend)\\n\\nNew \\"TextBox\\" {\\n    [Out \\"Text\\"] = LoginPage:field \\"Password\\"\\n}\\n\\nNew \\"TextButton\\" {\\n    [OnEvent \\"Activated\\"] = function()\\n        LoginPage:submit()\\n    end\\n}\\n```","params":[{"name":"validators","desc":"","lua_type":"{[string]:(any, (boolean)->())->(boolean)}"}],"returns":[{"desc":"","lua_type":"Form"}],"function_type":"static","source":{"line":194,"path":"src/Form.lua"}},{"name":"If","desc":"This functions open a conditional statement that reacts to changes of the value.\\nIt is commonly paired with `ElseIf` and `Else` to create a totally reactive control\\nflow.\\n\\n```lua\\nlocal State = Value(false)\\nlocal CheckBox = New \\"ImageButton\\" {\\n    [If(State)] = { -- Updates whenver the value `State` changes.\\n        Text = \\"Activated\\",\\n        [Else] = { -- If the state value is false\\n            Text = \\"Deactivated\\"\\n        }\\n    },\\n\\n    [OnEvent \\"Activated\\"] = function()\\n        State:set(not State:get())\\n    end\\n}\\n```","params":[{"name":"conditional","desc":"","lua_type":"PubTypes.StateObject<boolean>"}],"returns":[{"desc":"","lua_type":"SpecialKey"}],"function_type":"static","source":{"line":37,"path":"src/If.lua"}},{"name":"Iter","desc":"Iter has the same function as [Stir.Each], however it applies the\\nvalues of the list sequencially, instead of randomly.\\n\\n```lua\\nNew \\"Frame\\" {\\n\\tNew \\"UIGridLayout\\" {}\\n\\t[Iter(PlayerList)] = function(Key,Value)\\n\\t\\treturn New \\"TextLabel\\" {\\n\\t\\t\\tText = Value\\n\\t\\t}\\n\\tend\\n}\\n```\\n\\n:::warning\\n`Iter` will not work on dicts and table keys that are not numbers. Use `Each` for this case instead.\\n:::","params":[{"name":"list","desc":"","lua_type":"{any}"}],"returns":[{"desc":"","lua_type":"PubTypes.SpecialKey\\r\\n"}],"function_type":"static","source":{"line":27,"path":"src/Iter.lua"}},{"name":"Observe","desc":"A shorthand for using `Observer:onChange`, can also make it so it runs the\\ncallback when the callback is binded.\\n\\n```lua\\nlocal TimesChanged = 0\\nObserve(someState,function()\\n    TimesChanged += 1\\nend, true) -- RunOnBind is true.\\nprint(TimesChanged) --\x3e 1\\n```","params":[{"name":"State","desc":"","lua_type":"PubTypes.StateObject<any>"},{"name":"Fn","desc":"","lua_type":"()->()"},{"name":"RunOnBind","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"()->()\\r\\n"}],"function_type":"static","source":{"line":21,"path":"src/Observe.lua"}},{"name":"Switch","desc":"Has some of the same logic as `If`, however it is more used\\nto check if a state object has a specific value.\\n\\n```lua\\nlocal State = Value(false)\\nlocal CheckBox = New \\"TextButton\\" {\\n\\t[Switch(State)] = { -- Updates whenver the value `State` changes.\\n\\t\\t[true] = { -- If true\\n\\t\\t\\tText = \\"Activated\\"\\n\\t\\t},\\n\\t\\t[false] = { -- If false\\n\\t\\t\\tText = \\"Deactivated\\"\\n\\t\\t},\\n\\t\\t[Default] = { -- If the state value is any other value\\n\\t\\t\\tText = \\"What the....\\"\\n\\t\\t}\\n\\t},\\n\\t[OnEvent \\"Activated\\"] = function()\\n\\t\\tif math.random(1,20) < 5 then\\n\\t\\t\\tState:set(nil)\\n\\t\\telse\\n\\t\\t\\tState:set(not State:get())\\n\\t\\tend\\n\\tend\\n}\\n```","params":[{"name":"state","desc":"","lua_type":"PubTypes.StateObject<any>"}],"returns":[{"desc":"","lua_type":"SpecialKey"}],"function_type":"static","source":{"line":41,"path":"src/Switch.lua"}},{"name":"Template","desc":"Templates are like Components, except they accept\\nany instance property + custom properties that are handled\\ninside of itself. This is quite useful when\\ncreating a base for different components that have\\na similar structure.\\n\\n`Custom` have the same structure as `Allowed` in *Components*,\\nsame thing for `Callback`\\n\\n```lua\\nlocal BaseButton = Template({Type=\\"string\\"}, function(Props)\\n    return New (Props.Type..\\"Button\\") {}\\nend)\\n\\nlocal Image = BaseButton {Type=\\"Image\\"}\\nlocal Text = BaseButton {Type=\\"Text\\"}\\n\\nprint(Image.ClassName) --\x3e ImageButton\\nprint(Text.ClassName)  --\x3e TextButton\\n```","params":[{"name":"Custom","desc":"","lua_type":"{[string]: TypeNames}"},{"name":"Callback","desc":"","lua_type":"(Props: PropertyTable) -> (T)"}],"returns":[{"desc":"","lua_type":"function"}],"function_type":"static","source":{"line":36,"path":"src/Template.lua"}}],"properties":[{"name":"Conditions","desc":"A few presets computed presets that can be used inside the `If` specialkey.","lua_type":"{Equals: (v1:StateObject,v2:StateObject)->(Computed),NotEquals: (v1:StateObject,v2:StateObject)->(Computed),Greater: (v1:StateObject,v2:StateObject)->(Computed),Lesser: (v1:StateObject,v2:StateObject)->(Computed),GreaterEquals: (v1:StateObject,v2:StateObject)->(Computed),LesserEquals: (v1:StateObject,v2:StateObject)->(Computed)}","source":{"line":67,"path":"src/init.lua"}},{"name":"Default","desc":"Used inside `Switch` blocks, it will apply the properties it\'s passed as long as all\\nthe other cases inside the block fails.","lua_type":"Symbol","source":{"line":74,"path":"src/init.lua"}},{"name":"Else","desc":"Used inside `If` blocks, self-explinatory.","lua_type":"Symbol","source":{"line":80,"path":"src/init.lua"}}],"types":[{"name":"Symbol","desc":"Symbols like `Default` and `Else` are used for some special table keys\\r","lua_type":"userdata","source":{"line":61,"path":"src/init.lua"}}],"name":"Stir","desc":"The base table for every utilty.\\r","source":{"line":18,"path":"src/init.lua"}}')}}]);