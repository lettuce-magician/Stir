[{"title":"Installation","type":0,"sectionRef":"#","url":"/Stir/docs/intro","content":"","keywords":""},{"title":"After Installing...​","type":1,"pageTitle":"Installation","url":"/Stir/docs/intro#after-installing","content":"Check out these articles to get started on using Stir: API Docs "},{"title":"Rollback","type":0,"sectionRef":"#","url":"/Stir/api/Rollback","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#types","content":" "},{"title":"RollbackLog​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#RollbackLog","content":"&lt;/&gt; interface RollbackLog { Value: any Time: number Tick: number } A table that is returned by Rollback:get. Value is obviously the value that was registered at that time. Time is the time in seconds of when the log was registered relative to the time the Rollback object was created. Tick is the absolute time of when the log was registered in Unix Epoch. "},{"title":"Functions​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#functions","content":" "},{"title":"clear​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#clear","content":"&lt;/&gt; Rollback:clear() → () Clears all the logs while updating to get a new log as a starting point.  "},{"title":"update​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#update","content":"&lt;/&gt; Rollback:update( Val: any, force: boolean ) → () Tries to append a new log in the rollback and uses it as it's new value. If the current value of the state object has the same value as the last log, it will simply not append it (except when force is true).  "},{"title":"get​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#get","content":"&lt;/&gt; Rollback:get(index: number) → () Returns a log by index in the rollback. If index is not passed then it will return the last value that was registered.  "},{"title":"list​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#list","content":"&lt;/&gt; Rollback:list() → () Returns all the logs registered in the Rollback.  "},{"title":"count​","type":1,"pageTitle":"Rollback","url":"/Stir/api/Rollback#count","content":"&lt;/&gt; Rollback:count() → () Returns the total number of logs inside the Rollback. "},{"title":"Form","type":0,"sectionRef":"#","url":"/Stir/api/Form","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#types","content":" "},{"title":"Submission​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#Submission","content":"&lt;/&gt; interface Submission { id: string valid: boolean post: boolean data: {[string]:any} error: {[string]:string} }  "},{"title":"Functions​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#functions","content":" "},{"title":"clear​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#clear","content":"&lt;/&gt; Form:clear() → () Clears the last result and all property values.  "},{"title":"field​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#field","content":"&lt;/&gt; Form:field(name: string) → PubTypes.Value&lt;any&gt; Creates a value bound to a field inside the Form. Can be used alongside Out to get user input.  "},{"title":"submit​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#submit","content":"&lt;/&gt; Form:submit() → Submission Submits the form, returning the result of the submission.  "},{"title":"get​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#get","content":"&lt;/&gt; Form:get() → Submission Returns the result of the last submission, submitting one if it was cleared or does not exist.  "},{"title":"onSubmit​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#onSubmit","content":"&lt;/&gt; Form:onSubmit(fn: (result:PubTypes.Submission) → ()) → () → () Binds a callback for when the form is submitted, the callback will still be ran if there are validation errors on the result. Returns a function that disconnects the callback from the signal.  "},{"title":"onPost​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#onPost","content":"&lt;/&gt; Form:onPost(fn: (data: {[string]:any}) → ()) → () → () Binds a callback for when the form is posted, meaning it is completely fine with zero fatal errors from the validators. Returns a function that disconnects the callback from the signal.  "},{"title":"onError​","type":1,"pageTitle":"Form","url":"/Stir/api/Form#onError","content":"&lt;/&gt; Form:onError(fn: (data: {[string]:string}) → ()) → () → () Binds a callback that runs whenever an validation error (fatal or non-fatal) on a form field fails, passing the errors that the form submission had. "},{"title":"Stir","type":0,"sectionRef":"#","url":"/Stir/api/Stir","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#types","content":" "},{"title":"Symbol​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Symbol","content":"&lt;/&gt; type Symbol = userdata Symbols like Default and Else are used for some special table keys "},{"title":"Properties​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#properties","content":" "},{"title":"Conditions​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Conditions","content":"&lt;/&gt; Stir.Conditions: { Equals: ( v1:StateObject, v2:StateObject ) → (Computed), NotEquals: ( v1:StateObject, v2:StateObject ) → (Computed), Greater: ( v1:StateObject, v2:StateObject ) → (Computed), Lesser: ( v1:StateObject, v2:StateObject ) → (Computed), GreaterEquals: ( v1:StateObject, v2:StateObject ) → (Computed), LesserEquals: ( v1:StateObject, v2:StateObject ) → (Computed) } A few presets computed presets that can be used inside the If specialkey.  "},{"title":"Default​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Default","content":"&lt;/&gt; Stir.Default: Symbol Used inside Switch blocks, it will apply the properties it's passed as long as all the other cases inside the block fails.  "},{"title":"Else​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Else","content":"&lt;/&gt; Stir.Else: Symbol Used inside If blocks, self-explinatory.  "},{"title":"Any​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Any","content":"&lt;/&gt; Stir.Any: Symbol Used inside Stir.Component and Stir.Template for setting a value that can receive any type. "},{"title":"Functions​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#functions","content":" "},{"title":"AttributeBind​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#AttributeBind","content":"&lt;/&gt; Stir.AttributeBind( Inst: Instance , Attr: string ) → Value Does the exact same thing as Bind, however it uses an attribute instead of a property. local Mana = AttributeBind(Humanoid, &quot;Mana&quot;) local MaxMana = AttributeBind(Humanoid, &quot;MaxMana&quot;)   "},{"title":"Bind​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Bind","content":"&lt;/&gt; Stir.Bind( Inst: Instance , Prop: string ) → Value Binds a value to a property, and whenever the property updates, it also updates. Yes, Out exists however this is useful when you're just getting a property and you don't want to use Hydration for it, like getting Humanoid's Health. local Health = Bind(Humanoid, &quot;Health&quot;) local MaxHealth = Bind(Humanoid, &quot;MaxHealth&quot;)   "},{"title":"Child​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Child","content":"&lt;/&gt; Stir.Child(childName: string) → SpecialKey  This function is very useful when in pairs with Hydrate. What it simply does is that it hydrates the child of the current instance by name. If the child does not exist it will throw an error. local Frame = New &quot;Frame&quot; { [Children] = { New &quot;UIStroke&quot; {} } } print(Frame.UIStroke.Color) -- 0, 0, 0 Hydrate (Frame) { [Child &quot;UIStroke&quot;] = { Color = Color3.new(1,1,1) } } print(Frame.UIStroke.Color) -- 1, 1, 1   "},{"title":"Clone​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Clone","content":"&lt;/&gt; Stir.Clone(Inst: Instance ) → (Props:PubTypes.PropertyTable) → (typeof(Inst:Clone())) A shorthand for cloning instances and hydrating them in the spot. local ToDuplicate = -- insert here some code that creates an instance -- local AnDuplicate = Clone (ToDuplicate) { Parent = workspace } print(ToDuplicate == AnDuplicate) --&gt; false   "},{"title":"Component​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Component","content":"&lt;/&gt; Stir.Component( Allowed: {[string]: TypeNames}, Callback: (Props: PropertyTable) → (T)} ) → (Props: PropertyTable) → (T) Creates a component, which is essentially a piece of a UI Element inside a function that can be built by calling it with the specified arguments, however, this makes it easier to apply validation. Allowed params indicates the properties that are inside that component, the structure of the table should be the property name as key and default value/type (defining the value will auto-select its type). If the table includes a property of the instance that the component returns, it will automatically hydrate it (this does not apply to events). To allow the parameter to accept any type, set it to Stir.Any. Callback is the callback that returns the component itself, it receives all the allowed properties, incluinding instance properties, alongside their typings for autocompleting. local Button = Component({Text=&quot;string&quot;, Activated=&quot;function&quot;}, function(Props) return New &quot;TextButton&quot; { [OnEvent &quot;Activated&quot;] = Props.Activated } end) local Test = Button { Text = &quot;Hello World!&quot;, Activated = function() print(&quot;Clicked!&quot;) end } print(Test.Text) --&gt; Hello World! info Just reinforcing: this is almost no different from simply creating a function and returning an instance created by Fusion, this just adds typings, validation and auto-hydration.  "},{"title":"Each​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Each","content":"&lt;/&gt; Stir.Each(dict: PubTypes.CanBeState&lt;{[string]:any}&gt;) → PubTypes.SpecialKey Each is used for looping through a key/value pair table and adding children or adding specific properties. If the passed value is a state, then everytime the state updates, it will react accordingly. New &quot;Frame&quot; { New &quot;UIGridLayout&quot; {} [Each(Settings)] = function(Key,Value) return New &quot;TextLabel&quot; { Text = Key..&quot;: &quot;..Value } end } warning Each uses pairs for looping through the table, meaning list elements will not appear sequencially. In that case, use Iter instead for lists and sequencial values.  "},{"title":"ElseIf​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#ElseIf","content":"&lt;/&gt; Stir.ElseIf(conditional: PubTypes.CanBeState&lt;boolean&gt;) → SpecialKey  This function opens another clause inside an If statement. However unlike the If statement, it is not reactive, and only updates when the value inside If does. However this still checks if the passed condition is true before hydrating it. local State = Value(false) local CheckBox = New &quot;TextButton&quot; { [If(State)] = { -- Updates whenver the value `State` changes. Text = &quot;Activated&quot;, [ElseIf(State:get() == false)] = { -- if the state value is false Text = &quot;Deactivated&quot; }, [Else] = { -- If the state value is any other value Text = &quot;What the....&quot; } }, [OnEvent &quot;Activated&quot;] = function() if math.random(1,20) &lt; 5 then State:set(nil) else State:set(not State:get()) end end }   "},{"title":"Form​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Form","content":"&lt;/&gt; Stir.Form(validators: { [string]:(any, (boolean) → ()) → (boolean) }) → Form Creates a Form object, which is used for creating stuff like login pages and quizes. The first argument is a dictionary, with Form Field names as keys, and their validation function as values. The validator functions gets two parameters: The value that was submitted and a function that decides whenver the field will be allowed to post. The validator function needs to return a boolean which indicates if there are errors on the validated value, and an error message if there is an error. local LoginPage = Form { Password = function(CurrentValue:string, CanPost:(boolean, string)-&gt;(boolean, string)) return CanPost(#CurrentValue &gt;= 8, &quot;Password must be atleast 8 characters long!&quot;) end } LoginPage:onSubmit(function(result) print(result) end) LoginPage:onPost(function() print(&quot;Password posted successfully!&quot;) end) LoginPage:onError(function(errors) print(errors) end) New &quot;TextBox&quot; { [Out &quot;Text&quot;] = LoginPage:field &quot;Password&quot; } New &quot;TextButton&quot; { [OnEvent &quot;Activated&quot;] = function() LoginPage:submit() end }   "},{"title":"If​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#If","content":"&lt;/&gt; Stir.If(conditional: PubTypes.StateObject&lt;boolean&gt;) → SpecialKey  This functions open a conditional statement that reacts to changes of the value. It is commonly paired with ElseIf and Else to create a totally reactive control flow. local State = Value(false) local CheckBox = New &quot;ImageButton&quot; { [If(State)] = { -- Updates whenver the value `State` changes. Text = &quot;Activated&quot;, [Else] = { -- If the state value is false Text = &quot;Deactivated&quot; } }, [OnEvent &quot;Activated&quot;] = function() State:set(not State:get()) end }   "},{"title":"Iter​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Iter","content":"&lt;/&gt; Stir.Iter(list: {any}) → PubTypes.SpecialKey Iter has the same function as Stir.Each, however it applies the values of the list sequencially, instead of randomly. New &quot;Frame&quot; { New &quot;UIGridLayout&quot; {} [Iter(PlayerList)] = function(Key,Value) return New &quot;TextLabel&quot; { Text = Value } end } warning Iter will not work on dicts and table keys that are not numbers. Use Each for this case instead.  "},{"title":"Observe​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Observe","content":"&lt;/&gt; Stir.Observe( State: PubTypes.StateObject&lt;any&gt;, Fn: () → (), RunOnBind: boolean? ) → () → () A shorthand for using Observer:onChange, can also make it so it runs the callback when the callback is binded. local TimesChanged = 0 Observe(someState,function() TimesChanged += 1 end, true) -- RunOnBind is true. print(TimesChanged) --&gt; 1   "},{"title":"Rollback​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Rollback","content":"&lt;/&gt; Stir.Rollback(State: PubTypes.StateObject&lt;T&gt;) → () Creates a Rollback object, which captures whenever a state changes and logs it's value inside. local Number = Value(0) local Roll = Rollback(Number) while task.wait(1) do Number:set(Number:get()+1) print(Roll:get(), Roll:get(Roll:count()-1)) end   "},{"title":"Switch​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Switch","content":"&lt;/&gt; Stir.Switch(state: PubTypes.StateObject&lt;any&gt;) → SpecialKey  Has some of the same logic as If, however it is more used to check if a state object has a specific value. local State = Value(false) local CheckBox = New &quot;TextButton&quot; { [Switch(State)] = { -- Updates whenver the value `State` changes. [true] = { -- If true Text = &quot;Activated&quot; }, [false] = { -- If false Text = &quot;Deactivated&quot; }, [Default] = { -- If the state value is any other value Text = &quot;What the....&quot; } }, [OnEvent &quot;Activated&quot;] = function() if math.random(1,20) &lt; 5 then State:set(nil) else State:set(not State:get()) end end }   "},{"title":"Template​","type":1,"pageTitle":"Stir","url":"/Stir/api/Stir#Template","content":"&lt;/&gt; Stir.Template( Custom: {[string]: TypeNames}, Callback: (Props: PropertyTable) → (T) ) → function Templates are like Components, except they accept any instance property + custom properties that are handled inside of itself. This is quite useful when creating a base for different components that have a similar structure. Custom have the same structure as Allowed in Components, same thing for Callback local BaseButton = Template({Type=&quot;string&quot;}, function(Props) return New (Props.Type..&quot;Button&quot;) {} end) local Image = BaseButton {Type=&quot;Image&quot;} local Text = BaseButton {Type=&quot;Text&quot;} print(Image.ClassName) --&gt; ImageButton print(Text.ClassName) --&gt; TextButton  "}]